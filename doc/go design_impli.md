#### Go语言设计与实现 ####
- 编译原理
  - 词法分析(生成token序列)、语法分析-->AST
  - 类型检查、内建函数展开/改写（基于AST）
    - 概念
      ```
      类型的转换是显式的还是隐式的？
      编译器会帮助我们推断变量的类型么？这些具体的问题在这种语境下其实更有价值
      ```
    - 静态与动态类型
      - 静态类型和动态类型的编程语言其实也是两个不精确的表述，它们应该被称为使用静态类型检查和动态类型检查的编程语言
      - 静态类型检查
        ```
        静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上就满足了类型安全的要求，
        它也可以被看作是一种代码优化的方式，能够减少程序在运行时的类型检查。
        ```
      - 动态类型检查
        ```
        动态类型检查就是在运行时确定程序类型安全的过程，这个过程需要编程语言在编译时为所有的对象加入类型标签和信息，运行时就可以使用这些存储的类型信息
        来实现动态派发、向下转型、反射以及其他特性
        ```
      - Java 就同时使用了这两种检查的方法，不仅在编译期间对类型提前检查发现类型错误，还为对象添加了类型信息，这样能够在运行时使用反射根据对象的类型动态地执行方法减少了冗余代码。
  - 中间代码生成
    - 中间代码是指一种应用于抽象机器的编程语言，它设计的目的，是用来帮助我们分析计算机程序。
    - 中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易；Go 语言编译器的中间代码具有静态单赋值（SSA）的特性
    - SSA配置的初始化以及函数编译
  - 机器码生成
    - SSA 中间代码进行降级、执行架构特定的优化和重写并生成 obj.Prog 指令
    - 汇编器会将这些指令最终转换成机器码完成这次的编译
- 数据结构
  - 数组
    - 数组的定义（内存上一段连续的地址空间；同种类型元素的集合；数组的长度和元素类型）
    - 数组在初始化后就不可改变
    - 上限推导
    - 语句转换
      ``` 
      如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，
      如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。
      ```
    - 编译期检查、运行时检查，发现数组访问越界错误
    - 无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。
    - 对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成对内存的直接读写，在中间代码生成期间，编译器还会插入运行时方法 panicIndex 调用防止发生越界错误。
    - 初始化
      ``` 
      arr1 := [3]int{1, 2, 3}
      arr2 := [...]int{1, 2, 3}
      ```
  - 切片
    - 切片引入了一个抽象层，提供了对数组中部分片段的引用
    - 作为数组的引用，可在运行区间修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。
    - SliceHeader，其中包含数组指针、切片长度和容量，它也是切片在运行时的表示。
    - 切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用 range 遍历切片时也会在编译期间转换成形式更简单的代码
    - 切片的拷贝是整块儿内存区域的拷贝，这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。
    - 初始化
      ``` 
      arr[0:3] or slice[0:3]
      slice := []int{1, 2, 3}
      slice := make([]int, 10)
      ```
  - 哈希表
    - 理想的哈希函数：哈希无碰撞（哈希函数输出空间>输入空间）
    - 实际中，只能尽量使哈希结果均匀（减少碰撞、提高读写性能），并通过工程上的方法避免碰撞
    - 哈希碰撞的解决方法
      - 开放寻址法：核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中；开放寻址法中对性能影响最大的就是装载因子
      - 拉链法：实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构
        计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念
      - GO语言中使用了拉链法来解决哈希碰撞的问题实现了哈希表
    - 初始化
      ```  
      hash := map[string]int{
          "1": 2,
          "3": 4,
          "5": 6,
      }
      ```
  - 字符串
    - 实质为一个只读的字节数组,所有在字符串上执行的写入操作实际都是通过拷贝实现的。<br/>
      运行时还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 []byte 之后就可以进行，修改后通过类型转换就可以变回 string。
    - 一旦需要拼接的字符串非常大，拷贝带来的性能损失就是无法忽略的。
    - 每一个字符串在运行时都会使用如下的 StringHeader 结构体表示
      ```
      type StringHeader struct {
          Data uintptr
          Len  int
      }
      ```
    - 我们会经常会说字符串是一个只读的切片类型，这是因为切片在 Go 语言的运行时表示与字符串高度相似：
      ```
      type SliceHeader struct {
          Data uintptr
          Len  int
          Cap  int
      }
      ```
    - string和byte[]之间的转换，无论从哪种类型转换到另一种都需要对其中的内容进行拷贝，而内存拷贝的性能损耗会随着字符串和 []byte 长度的增长而增长。
    - 在做拼接和类型转换等操作时时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。
    - 初始化
      ``` 
      str1 := "this is a string"
      str2 := `{"author": "draven", "tags":
       ["golang"]}`
      ```
- 语言基础 
  - 函数调用
    - 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：    
      ``` 
      六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；
      六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；
      而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。
      ```
    - Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。入参的压栈顺序和 C 语言一样，都是从右到左。
    - Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。对比：
      ``` 
      C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；
        CPU 访问栈的开销比访问寄存器高几十倍3；
        需要单独处理函数参数过多的情况；
      Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；
        不需要考虑超过寄存器数量的参数应该如何传递；
        不需要考虑不同架构上的寄存器差异；
        函数入参和出参的内存空间需要在栈上进行分配；
      ```
    - 参数传递
      - Go 语言在传递参数时其实使用的就是传值的方式，接收方收到参数时会对这些参数进行复制。（值复制/指针地址复制），本质未指向的内存空间地址是否变化/复制内存空间或者复制指针地址。
      - Go 语言中对于整型和数组类型的参数都是值传递的，也就是在调用函数时会对内容进行拷贝，需要注意的是如果当前数组的大小非常的大，这种传值方式就会对性能造成比较大的影响。
      - 在传递数组或者内存占用非常大的结构体时，我们在一些函数中应该尽量使用指针作为参数类型来避免发生大量数据的拷贝而影响性能。
      - 参数传递规则：
        ``` 
        通过堆栈传递参数，入栈的顺序是从右到左；
        函数返回值通过堆栈传递并由调用者预先分配内存空间；
        调用函数时都是传值，接收方会对入参进行复制再计算；
        ```
  - 接口
    - Go 语言中的接口是一种内置的类型，它定义了一组方法的签名。
    - Go 语言中接口的实现都是隐式的，只需要实现接口中的方法即可。
      ``` 
      在 Java 中：实现接口需要显式的声明接口并实现所有方法；
      在 Go 中：实现接口的所有方法就隐式的实现了接口；
      ```
    - Go 语言的 interface{} 类型在语言内部是通过 emptyInterface 这个结体来表示的，其中的 rtype 字段用于表示变量的类型，另一个 word 字段指向内部封装的数据：
      ``` 
      type emptyInterface struct {
          typ  *rtype
          word unsafe.Pointer
      }
      ```
    - Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查。
    - 接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束
    - 两种接口：一种是带有一组方法的接口(iface)。 另一种是不带任何方法的interface{} (eface)。
    - interface{} 类型*不是任意类型，如果我们将类型转换成了 interface{} 类型，这边变量在运行期间的类型也发生了变化，获取变量类型时就会得到 interface{}
    - 指针实现接口 & 结构体实现接口
      - 接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到『一个类型』实现接口的两种方式
      ``` 
      使用结构体来实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。
      使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。
      ```
  - 反射
    ``` 
    reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。
    使用 reflect.TypeOf 和 reflect.ValueOf 能够获取 Go 语言中的变量对应的反射对象Type和Value。
    一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。
    ```
    - 三大法则
      - 从 interface{} 变量可以反射出反射对象；
        - Go 语言会在编译期间完成类型转换的工作，将变量的类型和值转换成了 interface{} 并等待运行期间使用 reflect 包获取接口中存储的信息。
      - 从反射对象可以获取 interface{} 变量；
      - 要修改反射对象，其值必须可设置；
- 常用关键字
  - for & range
    ``` 
    在汇编语言中，无论是经典的 for 循环还是 for/range 循环都会使用 JMP 以及相关的命令跳回循环体的开始位置来多次执行代码的逻辑。
    从不同循环具有相同的汇编代码可以猜到，使用 for/range 的控制结构最终也会被 Go 语言编译器转换成普通的 for 循环
    ```
    - 因为数组、切片和哈希表占用的内存空间都是连续的,清空一个切片或者哈希表时,编译器会直接使用 runtime.memclrNoHeapPointers 清空切片中的数据
    - 对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新的变量 ha，在赋值的过程中就发生了拷贝，所以我们遍历的切片已经不是原始的切片变量了。 
    - 而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 v2 变量存储切片中的元素，循环中使用的这个变量 v2 会在每一次迭代被重新赋值，在赋值时也发生了拷贝。
    - Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。
      通过 runtime.fastrand 生成一个随机数帮助我们随机选择一个桶开始遍历。
    - 哈希表遍历的顺序，首先会选出一个正常桶开始遍历，随后遍历对应的所有溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。
  - select
    -  
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      