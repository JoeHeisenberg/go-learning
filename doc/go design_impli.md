#### Go语言设计与实现 ####
- 编译原理
  - 词法分析(生成token序列)、语法分析-->AST
  - 类型检查、内建函数展开/改写（基于AST）
    - 概念
      ```
      类型的转换是显式的还是隐式的？
      编译器会帮助我们推断变量的类型么？这些具体的问题在这种语境下其实更有价值
      ```
    - 静态与动态类型
      - 静态类型和动态类型的编程语言其实也是两个不精确的表述，它们应该被称为使用静态类型检查和动态类型检查的编程语言
      - 静态类型检查
        ```
        静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上就满足了类型安全的要求，
        它也可以被看作是一种代码优化的方式，能够减少程序在运行时的类型检查。
        ```
      - 动态类型检查
        ```
        动态类型检查就是在运行时确定程序类型安全的过程，这个过程需要编程语言在编译时为所有的对象加入类型标签和信息，运行时就可以使用这些存储的类型信息
        来实现动态派发、向下转型、反射以及其他特性
        ```
      - Java 就同时使用了这两种检查的方法，不仅在编译期间对类型提前检查发现类型错误，还为对象添加了类型信息，这样能够在运行时使用反射根据对象的类型动态地执行方法减少了冗余代码。
  - 中间代码生成
    - 中间代码是指一种应用于抽象机器的编程语言，它设计的目的，是用来帮助我们分析计算机程序。
    - 中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易；Go 语言编译器的中间代码具有静态单赋值（SSA）的特性
    - SSA配置的初始化以及函数编译
  - 机器码生成
    - SSA 中间代码进行降级、执行架构特定的优化和重写并生成 obj.Prog 指令
    - 汇编器会将这些指令最终转换成机器码完成这次的编译
    
    
- 数据结构
  - 数组
    - 数组的定义（内存上一段连续的地址空间；同种类型元素的集合；数组的长度和元素类型）
    - 数组在初始化后就不可改变
    - 上限推导
    - 语句转换
      ``` 
      如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，
      如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。
      ```
    - 编译期检查、运行时检查，发现数组访问越界错误
    - 无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。
    - 对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成对内存的直接读写，在中间代码生成期间，编译器还会插入运行时方法 panicIndex 调用防止发生越界错误。
    - 初始化
      ``` 
      arr1 := [3]int{1, 2, 3}
      arr2 := [...]int{1, 2, 3}
      ```
  - 切片
    - 切片引入了一个抽象层，提供了对数组中部分片段的引用
    - 作为数组的引用，可在运行区间修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。
    - SliceHeader，其中包含数组指针、切片长度和容量，它也是切片在运行时的表示。
    - 切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用 range 遍历切片时也会在编译期间转换成形式更简单的代码
    - 切片的拷贝是整块儿内存区域的拷贝，这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。
    - 初始化
      ``` 
      arr[0:3] or slice[0:3]
      slice := []int{1, 2, 3}
      slice := make([]int, 10)
      ```
  - 哈希表
    - 理想的哈希函数：哈希无碰撞（哈希函数输出空间>输入空间）
    - 实际中，只能尽量使哈希结果均匀（减少碰撞、提高读写性能），并通过工程上的方法避免碰撞
    - 哈希碰撞的解决方法
      - 开放寻址法：核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中；开放寻址法中对性能影响最大的就是装载因子
      - 拉链法：实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构
        计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念
      - GO语言中使用了拉链法来解决哈希碰撞的问题实现了哈希表
    - 初始化
      ```  
      hash := map[string]int{
          "1": 2,
          "3": 4,
          "5": 6,
      }
      ```
  - 字符串
    - 实质为一个只读的字节数组,所有在字符串上执行的写入操作实际都是通过拷贝实现的。<br/>
      运行时还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 []byte 之后就可以进行，修改后通过类型转换就可以变回 string。
    - 一旦需要拼接的字符串非常大，拷贝带来的性能损失就是无法忽略的。
    - 每一个字符串在运行时都会使用如下的 StringHeader 结构体表示
      ```
      type StringHeader struct {
          Data uintptr
          Len  int
      }
      ```
    - 我们会经常会说字符串是一个只读的切片类型，这是因为切片在 Go 语言的运行时表示与字符串高度相似：
      ```
      type SliceHeader struct {
          Data uintptr
          Len  int
          Cap  int
      }
      ```
    - string和byte[]之间的转换，无论从哪种类型转换到另一种都需要对其中的内容进行拷贝，而内存拷贝的性能损耗会随着字符串和 []byte 长度的增长而增长。
    - 在做拼接和类型转换等操作时时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。
    - 初始化
      ``` 
      str1 := "this is a string"
      str2 := `{"author": "draven", "tags":
       ["golang"]}`
      ```
      
      
- 语言基础 
  - 函数调用
    - 当我们在 x86_64 的机器上使用 C 语言中调用函数时，参数都是通过寄存器和栈传递的，其中：    
      ``` 
      六个以及六个以下的参数会按照顺序分别使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递；
      六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中；
      而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。
      ```
    - Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。入参的压栈顺序和 C 语言一样，都是从右到左。
    - Go 语言使用栈作为参数和返回值传递的方法是综合考虑后的设计，选择这种设计意味着编译器会更加简单、更容易维护。对比：
      ``` 
      C 语言的方式能够极大地减少函数调用的额外开销，但是也增加了实现的复杂度；
        CPU 访问栈的开销比访问寄存器高几十倍3；
        需要单独处理函数参数过多的情况；
      Go 语言的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能；
        不需要考虑超过寄存器数量的参数应该如何传递；
        不需要考虑不同架构上的寄存器差异；
        函数入参和出参的内存空间需要在栈上进行分配；
      ```
    - 参数传递
      - Go 语言在传递参数时其实使用的就是传值的方式，接收方收到参数时会对这些参数进行复制。（值复制/指针地址复制），本质未指向的内存空间地址是否变化/复制内存空间或者复制指针地址。
      - Go 语言中对于整型和数组类型的参数都是值传递的，也就是在调用函数时会对内容进行拷贝，需要注意的是如果当前数组的大小非常的大，这种传值方式就会对性能造成比较大的影响。
      - 在传递数组或者内存占用非常大的结构体时，我们在一些函数中应该尽量使用指针作为参数类型来避免发生大量数据的拷贝而影响性能。
      - 参数传递规则：
        ``` 
        通过堆栈传递参数，入栈的顺序是从右到左；
        函数返回值通过堆栈传递并由调用者预先分配内存空间；
        调用函数时都是传值，接收方会对入参进行复制再计算；
        ```
  - 接口
    - Go 语言中的接口是一种内置的类型，它定义了一组方法的签名。
    - Go 语言中接口的实现都是隐式的，只需要实现接口中的方法即可。
      ``` 
      在 Java 中：实现接口需要显式的声明接口并实现所有方法；
      在 Go 中：实现接口的所有方法就隐式的实现了接口；
      ```
    - Go 语言的 interface{} 类型在语言内部是通过 emptyInterface 这个结体来表示的，其中的 rtype 字段用于表示变量的类型，另一个 word 字段指向内部封装的数据：
      ``` 
      type emptyInterface struct {
          typ  *rtype
          word unsafe.Pointer
      }
      ```
    - Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查。
    - 接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束
    - 两种接口：一种是带有一组方法的接口(iface)。 另一种是不带任何方法的interface{} (eface)。
    - interface{} 类型不是任意类型，如果我们将类型转换成了 interface{} 类型，这边变量在运行期间的类型也发生了变化，获取变量类型时就会得到 interface{}
    - 指针实现接口 & 结构体实现接口
      - 接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到『一个类型』实现接口的两种方式
      ``` 
      使用结构体来实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。
      使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。
      ```
  - 反射
    ``` 
    reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象。
    使用 reflect.TypeOf 和 reflect.ValueOf 能够获取 Go 语言中的变量对应的反射对象Type和Value。
    一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。
    ```
    - 三大法则
      - 从 interface{} 变量可以反射出反射对象；
        - Go 语言会在编译期间完成类型转换的工作，将变量的类型和值转换成了 interface{} 并等待运行期间使用 reflect 包获取接口中存储的信息。
      - 从反射对象可以获取 interface{} 变量；
      - 要修改反射对象，其值必须可设置；


- 常用关键字
  - for & range
    ``` 
    在汇编语言中，无论是经典的 for 循环还是 for/range 循环都会使用 JMP 以及相关的命令跳回循环体的开始位置来多次执行代码的逻辑。
    从不同循环具有相同的汇编代码可以猜到，使用 for/range 的控制结构最终也会被 Go 语言编译器转换成普通的 for 循环
    ```
    - 因为数组、切片和哈希表占用的内存空间都是连续的,清空一个切片或者哈希表时,编译器会直接使用 runtime.memclrNoHeapPointers 清空切片中的数据
    - 对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新的变量 ha，在赋值的过程中就发生了拷贝，所以我们遍历的切片已经不是原始的切片变量了。 
    - 而遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 v2 变量存储切片中的元素，循环中使用的这个变量 v2 会在每一次迭代被重新赋值，在赋值时也发生了拷贝。
    - Go 团队在设计哈希表的遍历时就不想让使用者依赖固定的遍历顺序，所以引入了随机数保证遍历的随机性。
      通过 runtime.fastrand 生成一个随机数帮助我们随机选择一个桶开始遍历。
    - 哈希表遍历的顺序，首先会选出一个正常桶开始遍历，随后遍历对应的所有溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。
    - 遍历字符串的过程与数组、切片和哈希表非常相似，只是在遍历时会获取字符串中索引对应的字节并将字节转换成 rune。遍历字符串时拿到的值都是 rune 类型的变量。
    - range对channel的遍历，循环会使用 <-ch 从管道中取出等待处理的值，这个操作会调用 runtime.chanrecv2 并阻塞当前的协程，直到管道中有返回值。
  - select
    - select 关键字能够让 Goroutine 同时等待多个 Channel 的可读或者可写，在多个文件或者 Channel 发生状态改变之前，select 会一直阻塞当前线程或者 Goroutine。
    - 当 select 中的两个 case 同时被触发时，就会随机选择一个 case 执行。
    - 以上在select 控制结构中不包含 default 语句时成立，包含default 语句时，不会阻塞当前的 Goroutine。
    - select内多个case条件同时满足时，随机选择一个执行，避免饥饿产生
    - 编译器的重写和优化，编译阶段和运行时的优化
    - select执行过程：
      - 直接阻塞。
        ```
        空的 select 语句会被转换成 runtime.block 函数的调用，直接挂起当前 Goroutine；
        ```
      - 单一管道。
        ```
        如果 select 语句中只包含一个 case，就会被转换成 if ch == nil { block }; n; 表达式；
        首先判断操作的 Channel 是不是空的,当 case 中的 Channel 是空指针时，就会直接挂起当前 Goroutine 并永久休眠；然后执行 case 结构中的内容；
        ```
      - 非阻塞操作。当 select 中仅包含两个 case，并且其中一个是 default 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。
        ``` 
        如果 select 语句中只包含两个 case 并且其中一个是 default，那么会使用 runtime.selectnbrecv 和 runtime.selectnbsend 非阻塞地执行收发操作；
        ```
      - 常见默认流程。将所有的 case 转换成包含 Channel 以及类型等信息的 runtime.scase 结构体；
        ``` 
        在默认情况下会通过 runtime.selectgo 函数获取执行 case 的索引，并通过多个 if 语句执行对应 case 中的代码；
        在编译器已经对 select 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 runtime.selectgo 函数，该函数会按照以下的流程执行：
        随机生成一个遍历的轮询顺序 pollOrder 并根据 Channel 地址生成锁定顺序 lockOrder；
        根据 pollOrder 遍历所有的 case 查看是否有可以立刻处理的 Channel；
        如果存在就直接获取 case 对应的索引并返回；
        如果不存在就会创建 runtime.sudog 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 runtime.gopark 挂起当前 Goroutine 等待调度器的唤醒；
        当调度器唤醒当前 Goroutine 时就会再次按照 lockOrder 遍历所有的 case，从中查找需要被处理的 runtime.sudog 结构对应的索引；select 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。   
        ```      
    - 从一个关闭 Channel 中接收数据会直接清除 Channel 中的相关内容；向一个关闭的 Channel 发送数据就会直接 panic 造成程序崩溃：    
  - defer
    - defer 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。
    - defer使用的两个问题
      - defer 关键字的调用时机以及多次调用 defer 时执行顺序是如何确定的；
      - defer 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果；
    - defer 关键字的实现主要依靠编译器和运行时的协作。
      - 编译期；
        将 defer 关键字被转换 runtime.deferproc；
        在调用 defer 关键字的函数返回之前插入 runtime.deferreturn；
      - 运行时：
        runtime.deferproc 会将一个新的 runtime._defer 结构体追加到当前 Goroutine 的链表头；
        runtime.deferreturn 会从 Goroutine 的链表中取出 runtime._defer 结构并依次执行；
      - 后调用的 defer 函数会先执行：
        后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面；
        运行 runtime._defer 时是从前到后依次执行；
      - 函数的参数会被预先计算；
        调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，参数的计算在调用defer时完成，而不是在方法返回时执行计算；
  - panic和recover
    - 程序崩溃和恢复的过程：
      - 编译器会负责做转换关键字的工作；
        将 panic 和 recover 分别转换成 runtime.gopanic 和 runtime.gorecover；<br/>
        将 defer 转换成 deferproc 函数；<br/>
      - 在调用 defer 的函数末尾调用 deferreturn 函数；
        在运行过程中遇到 gopanic 方法时，会从 Goroutine 的链表依次取出 _defer 结构体并执行；<br/>
      - 如果调用延迟执行函数时遇到了 gorecover 就会将 _panic.recovered 标记成 true 并返回 panic 的参数；<br/>
        在这次调用结束之后，gopanic 会从 _defer 结构体中取出程序计数器 pc 和栈指针 sp 并调用 recovery 函数进行恢复程序；<br/>
        recovery 会根据传入的 pc 和 sp 跳转回 deferproc；<br/>
        编译器自动生成的代码会发现 deferproc 的返回值不为 0，这时会跳回 deferreturn 并恢复到正常的执行流程；<br/>
      - 如果没有遇到 gorecover 就会依次遍历所有的 _defer 结构，并在最后调用 fatalpanic 中止程序、打印 panic 的参数并返回错误码 2；<br/>
        分析的过程涉及了很多语言底层的知识，源代码阅读起来也比较晦涩，其中充斥着反常规的控制流程，通过程序计数器来回跳转，不过对于我们理解程序的执行流程还是很有帮助。
  - make和new
    - make 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel。
    - new 的作用是根据传入的类型在堆上分配一片内存空间并返回指向这片内存空间的指针。


- 并发编程
  - 上下文Context
    - 在多个 Goroutine 之间同步信号、为请求设置截止日期并传递参数和信息。
    - 默认上下文，context.Background() 是上下文中最顶层的默认值。所有其他的上下文都应该从 context.Background() 演化出来。<br/>
      在多数情况下如果函数没有上下文作为入参，我们往往都会使用 context.Background() 作为起始的 Context 向下传递。
    - Go 语言中的 Context 的主要作用还是在多个 Goroutine 或者模块之间同步取消信号或者截止日期，用于减少对资源的消耗和长时间占用，避免资源浪费，<br/>
      虽然传值也是它的功能之一，但是这个功能我们还是很少用到。<br/>
      在真正使用传值的功能时我们也应该非常谨慎，不能将请求的所有参数都使用 Context 进行传递，这是一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。
  - 同步原语与锁
    - Mutex
      - 互斥锁的结构表示(锁状态，锁状态信号量)，内存结构(waitersCount,starving,woken,locked)，三种状态(starving,woken,locked)，两种模式(正常模式、饥饿模式)，加锁原理(CAS、自旋)
      - 只有在普通模式下才可能进入自旋，除了模式的限制之外，runtime_canSpin 方法中会判断当前方法是否可以进入自旋，进入自旋的条件非常苛刻:<br/>
        运行在多 CPU 的机器上；<br/>
        当前 Goroutine 为了获取该锁进入自旋的次数小于四次；<br/>
        当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列是空的；<br/>
        一旦当前 Goroutine 能够进入自旋就会调用 runtime_doSpin，它最终调用汇编语言编写的方法 procyield 并执行指定次数的 PAUSE 指令，PAUSE 指令什么都不会做，但是会消耗 CPU 时间，每次自旋都会调用 30 次 PAUSE
      - Mutex 其实就是对更底层的信号量进行封装，对外提供更加易用的 API，runtime_SemacquireMutex 会在方法中不断调用 goparkunlock 将当前 Goroutine 陷入休眠等待信号量可以被获取。
      ``` 
      互斥锁的加锁的过程比较复杂，涉及自旋、信号量以及 Goroutine 调度等概念：
      如果互斥锁处于初始化状态，就会直接通过置位 mutexLocked 加锁；
      如果互斥锁处于 mutexLocked 并且在普通模式下工作，就会进入自旋，执行 30 次 PAUSE 指令消耗 CPU 时间等待锁的释放；
      如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会被切换到饥饿模式；
      互斥锁在正常情况下会通过 runtime_SemacquireMutex 方法将调用 Lock 的 Goroutine 切换至休眠状态，等待持有信号量的 Goroutine 唤醒当前协程；
      如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，当前 Goroutine 会将互斥锁切换回正常模式；
      
      互斥锁的解锁过程相对来说就比较简单，对于普通模式和饥饿模式的处理有一些不同：
      如果互斥锁已经被解锁，那么调用 Unlock 会直接抛出异常；
      如果互斥锁处于饥饿模式，会直接将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位；
      如果互斥锁处于普通模式，并且没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁就会直接返回，在其他情况下回通过 runtime_Semrelease 唤醒对应的 Goroutine；
      ```
    - RWMutex
      - RWMutex 在 Mutex 之上提供了额外的读写分离功能，能够在读请求远远多于写请求时提供性能上的提升，我们也可以在场景合适时选择读写互斥锁。
    - WaitGroup
      - 可以用于等待一系列的 Goroutine 的返回.
      - 通过 WaitGroup 我们可以在多个 Goroutine 之间非常轻松地同步信息，原本顺序执行的代码也可以在多个 Goroutine 中并发执行，加快了程序处理的速度,<br>
        通过 Done 来传递单个任务完成的信号，只有在所有的 Goroutine 都执行完毕之后 Wait 方法才会返回。
      - WaitGroup 结构体中的noCopy变量保证WaitGroup不会被开发者通过再赋值的方式进行拷贝，进而导致一些诡异的行为。
      - 一些总结：
      ``` 
      Add 不能在和 Wait 方法在 Goroutine 中并发调用，一旦出现就会造成程序崩溃；
      WaitGroup 必须在 Wait 方法返回之后才能被重新使用；
      Done 只是对 Add 方法的简单封装，我们可以向 Add 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine；
      可以同时有多个 Goroutine 等待当前 WaitGroup 计数器的归零，这些 Goroutine 也会被『同时』唤醒；
      ```
    - Once
      - 保证在 Go 程序运行期间 Once 对应的某段代码只会执行一次。
      - 使用互斥锁和 atomic 提供的方法实现了某个函数在程序运行期间只能执行一次的语义
      ``` 
      Do 方法中传入的函数只会被执行一次，哪怕函数中发生了 panic；
      两次调用 Do 方法传入不同的函数时只会执行第一次调用的函数；
      ```
    - Cond
      - Cond 其实是一个条件变量，通过 Cond 我们可以让一系列的 Goroutine 都在触发某个事件或者条件时才被唤醒，每一个 Cond 结构体都包含一个互斥锁 L。
      - Cond 的结构体中包含 noCopy 和 copyChecker 两个字段，前者用于保证 Cond 不会再编译期间拷贝，后者保证在运行期间发生拷贝会直接 panic。
      - 与 Mutex 相比，Cond 还是一个不被所有人都清楚和理解的同步机制，它提供了类似队列的 FIFO 的等待机制，同时也提供了 Signal 和 Broadcast 两种不同的唤醒方法，<br/>
        相比于使用 for {} 忙碌等待，使用 Cond 能够在遇到长时间条件无法满足时将当前处理器让出的功能，如果我们合理使用还是能够在一些情况下提升性能。
      ```
      Wait 方法在调用之前一定要使用 L.Lock 持有该资源，否则会发生 panic 导致程序崩溃；
      Signal 方法唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine；
      Broadcast 虽然是广播通知全部等待的 Goroutine，但是真正被唤醒时也是按照一定顺序的；
      ```
    - ErrGroup
      - 子仓库 x/sync 中的包 errgroup 其实就为我们在一组 Goroutine 中提供了同步、错误传播以及上下文取消的功能
    - Semaphore
    - SingleFlight
  - 定时器
  - Channel
  - Goroutine















    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      