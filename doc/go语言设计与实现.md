#### Go语言设计与实现 ####
- 编译原理
  - 词法、语法分析-->AST
  - 类型检查、内建函数展开/改写（基于AST）
    - 概念
      ```
      类型的转换是显式的还是隐式的？
      编译器会帮助我们推断变量的类型么？这些具体的问题在这种语境下其实更有价值
      ```
    - 静态与动态类型
      - 静态类型和动态类型的编程语言其实也是两个不精确的表述，它们应该被称为使用静态类型检查和动态类型检查的编程语言
      - 静态类型检查
        ```
        静态类型检查是基于对源代码的分析来确定运行程序类型安全的过程，如果我们的代码能够通过静态类型检查，那么当前程序在一定程度上就满足了类型安全的要求，它也可以被看作是一种代码优化的方式，能够减少程序在运行时的类型检查。
        ```
      - 动态类型检查
        ```
        动态类型检查就是在运行时确定程序类型安全的过程，这个过程需要编程语言在编译时为所有的对象加入类型标签和信息，运行时就可以使用这些存储的类型信息来实现动态派发、向下转型、反射以及其他特性
        ```
      - Java 就同时使用了这两种检查的方法，不仅在编译期间对类型提前检查发现类型错误，还为对象添加了类型信息，这样能够在运行时使用反射根据对象的类型动态地执行方法减少了冗余代码。
  - 中间代码生成
    - 中间代码是指一种应用于抽象机器的编程语言，它设计的目的，是用来帮助我们分析计算机程序。
    - 中间代码是一种更接近机器语言的表示形式，对中间代码的优化和分析相比直接分析高级编程语言更容易；Go 语言编译器的中间代码具有静态单赋值（SSA）的特性
    - SSA配置的初始化以及函数编译
  - 机器码生成
    - SSA 中间代码进行降级、执行架构特定的优化和重写并生成 obj.Prog 指令
    - 汇编器会将这些指令最终转换成机器码完成这次的编译
- 数据结构
  - 数组
    - 上限推导
    - 语句转换
    ``` 
    如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，
    如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。
    ```
    - 编译期检查、运行时检查，发现数组访问越界错误
    - 无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与。
    - 对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成对内存的直接读写，在中间代码生成期间，编译器还会插入运行时方法 panicIndex 调用防止发生越界错误。
  - 切片
    - 切片引入了一个抽象层，提供了对数组中部分片段的引用
    - 作为数组的引用，可在运行区间修改它的长度，如果底层的数组长度不足就会触发扩容机制，切片中的数组就会发生变化，不过在上层看来切片时没有变化的，上层只需要与切片打交道不需要关心底层的数组变化。
    - SliceHeader，其中包含数组指针、切片长度和容量，它也是切片在运行时的表示。
    - 切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，使用 range 遍历切片时也会在编译期间转换成形式更简单的代码
    - 切片的拷贝是整块儿内存区域的拷贝，这个操作还是会占用非常多的资源，在大切片上执行拷贝操作时一定要注意性能影响。